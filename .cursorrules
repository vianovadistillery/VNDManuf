

üß± Cursor Rules ‚Äî Alembic & SQLite Safety

Purpose: Prevent migrations that break on SQLite (no ALTER ... ADD CONSTRAINT, limited type changes, etc.), enforce idempotency, and keep alembic check clean.

Golden Rules (follow for every migration)

Always batch mode for SQLite

In db/alembic/env.py ensure:

context.configure(
    connection=connection,
    target_metadata=target_metadata,
    render_as_batch=True,
    compare_type=True,
    compare_server_default=True,
)


At the top of each migration‚Äôs upgrade() and downgrade():

from alembic import op
import sqlalchemy as sa
bind = op.get_bind()
if bind.dialect.name == "sqlite":
    bind.execute(sa.text("PRAGMA foreign_keys=ON"))


Use batch_alter_table(..., recreate="always") for ANY change to existing tables

Never call op.add_column/op.drop_column/op.create_foreign_key/op.drop_constraint directly on SQLite tables.

Wrap changes like:

with op.batch_alter_table("table_name", recreate="always") as b:
    # add/drop columns, change nullability, types, defaults
    # add inline FKs via new column definitions only when recreating table


Create FKs only when creating a table or during batch recreation

SQLite can‚Äôt ALTER TABLE ... ADD CONSTRAINT.

For new tables, define FKs with sa.ForeignKey or sa.ForeignKeyConstraint inline in op.create_table(...).

For existing tables, add the FK during batch_alter_table(..., recreate="always").

Never rely on implicit ALTERs‚Äîrecreate instead

For type changes, nullability flips, default changes, or unique constraints: use batch recreate.

Do not attempt primary key changes on SQLite; redesign instead.

Guard every create/drop with existence checks

Prevent duplicate column/index/constraint errors:

bind = op.get_bind()
insp = sa.inspect(bind)
cols = [c["name"] for c in insp.get_columns("table_name")]
if "new_col" not in cols:
    with op.batch_alter_table("table_name", recreate="always") as b:
        b.add_column(sa.Column("new_col", sa.String(50)))
# Index guard
existing_idx = [ix["name"] for ix in insp.get_indexes("table_name")]
if "ix_table_col" not in existing_idx:
    op.create_index("ix_table_col", "table_name", ["col"])


Name constraints & indexes consistently

Index: ix_<table>_<col>[__<col2>] (use op.f() if you prefer)

Unique: uq_<table>_<cols>

FK: fk_<table>__<localcol>__<reftable>

PK: pk_<table>

Keep names stable across recreations.

Prefer portable column types

Use String, Integer, Numeric(precision=12, scale=4), Boolean, Date, DateTime, Text.

Avoid dialect-specific types and Enum (use String + check constraint if needed).

Server defaults & timestamps

If you need defaults, set Python-side in the model or set SQL default only during batch recreate.

Keep created_at/updated_at as DateTime(); update updated_at in app layer.

Never mix multiple risky ops in one statement

Don‚Äôt add a column and set an FK on it with a separate create_foreign_key.

Instead, add the column and FK together inside a single batch_alter_table(..., recreate="always").

Idempotent removes

Dropping indexes/columns/tables must not error if already gone (wrap with inspect/try-except).

Run gates before commit

Must pass:

alembic upgrade head

alembic check ‚Üí ‚Äúno new upgrade operations‚Äù

If alembic check shows drift, update the migration (not the model) until it‚Äôs clean.

Downgrades

Provide a logical reverse where feasible (batch recreate again). If not reasonably safe, explicitly document that downgrade is a no-op and explain why.

UUIDs & IDs

Use String(36) with Python-side default (uuid4) for id columns; don‚Äôt retrofit PK type changes on SQLite.

Don‚Äôt drop data silently

When removing a column/table, document migration notes; if data migration is needed, do it explicitly before dropping.

Migration messages

Migration filenames must describe scope, e.g.
work_orders_v2_cost_rates_batch_seq_type_fixes.

Pre-PR Checklist (Cursor must enforce)

Database Migrations:
 env.py has render_as_batch=True, compare_type=True, compare_server_default=True.

 Every existing-table change is within batch_alter_table(..., recreate="always").

 New tables define FKs inline; existing tables add FKs only during batch recreate.

 All create/drop actions are guarded (inspect/try/except) to be idempotent.

 Constraint & index names match the naming scheme.

 Types are portable (no dialect-only or Enum).

 alembic upgrade head runs clean on SQLite.

 alembic check reports no new upgrade operations.

 Downgrade provided or documented as intentionally limited.

 Commit message: "Migrations: <short scope> (SQLite batch-safe)".

Dash Callbacks:
 All Input/Output/State component IDs in callbacks exist in layout files (verify with grep).

 No duplicate Outputs without allow_duplicate=True.

 All component IDs match exactly (case-sensitive) between callbacks and layout.

 Conditional components (modals, tabs) have appropriate prevent_initial_call settings.

Code Snippets Cursor Should Reuse

Batch alter helper:

def has_column(insp, table, col):
    return any(c["name"] == col for c in insp.get_columns(table))

def has_index(insp, table, name):
    return any(ix["name"] == name for ix in insp.get_indexes(table))


Safe index create:

bind = op.get_bind()
insp = sa.inspect(bind)
if not has_index(insp, "inventory_movements", "ix_movements_product_ts"):
    op.create_index(
        "ix_movements_product_ts",
        "inventory_movements",
        ["product_id", "timestamp"]
    )


Safe drop table:

if "work_order_items" in sa.inspect(op.get_bind()).get_table_names():
    for ix in ("ix_wo_items_batch_code","ix_wo_items_product_id","ix_wo_items_work_order_id"):
        try: op.drop_index(ix, table_name="work_order_items")
        except Exception: pass
    op.drop_table("work_order_items")

[anti_goals]
- Do not generate PDF renderers before text renderers are stable and golden tests pass.
- Do not introduce additional frameworks (ORMs, API layers) beyond the agreed stack without updating brief.md.
- Do not bypass migrations by creating tables ad-hoc.

[alembic_sqlite_safety]
Purpose: Ensure all database migrations run safely with SQLite and do not crash Cursor agents during automated operations such as alembic check, schema upgrades, or autogeneration.

Core Principles:
- SQLite has limited DDL support: No ALTER TABLE ADD CONSTRAINT, No ALTER TABLE ALTER COLUMN, Limited type change support.
- Table recreation (batch_alter_table(recreate="always")) works safely.
- All migrations must use Alembic's batch mode and idempotent guards.

Safe Environment Configuration:
- In db/alembic/env.py, context.configure() MUST include: render_as_batch=True, compare_type=True, compare_server_default=True.
- At top of file or inside run_migrations_online() add: bind = connection; if bind.dialect.name == "sqlite": bind.execute(sa.text("PRAGMA foreign_keys=ON"))

Migration Rules (MUST FOLLOW):
1. Always use batch mode for existing tables:
   - Wrap every schema change in: with op.batch_alter_table("table_name", recreate="always") as b: ...
   - NEVER call op.add_column(), op.drop_column(), op.create_foreign_key() directly on SQLite tables.

2. Only add foreign keys when creating or recreating tables:
   - Define FKs inline in op.create_table().
   - For existing tables, add them only inside batch_alter_table(recreate="always") block.

3. Guard against duplicates:
   - Before adding/dropping columns, constraints, or indexes, check existence:
     bind = op.get_bind(); insp = sa.inspect(bind); cols = [c["name"] for c in insp.get_columns("table_name")]
     if "new_col" not in cols: ... (then add)

4. Use portable SQLAlchemy types:
   - Allowed: Integer, String, Text, Numeric(precision=12, scale=4), Boolean, DateTime, Date.
   - Avoid: Dialect-specific types (e.g. DOUBLE PRECISION), Enum (use String + check constraints instead).

5. Always name constraints consistently:
   - PK: pk_<table>, FK: fk_<table>__<localcol>__<reftable>, Index: ix_<table>_<col>, Unique: uq_<table>_<col>

6. Make every migration idempotent:
   - If an object (column, index, table) already exists, skip creating it instead of failing.

7. Don't drop data silently:
   - If data migration is required, make it explicit with op.execute().

Cursor Agent Behaviour Rules:
- MUST use python scripts/alembic_check_safe.py instead of raw alembic check.
- MUST use scripts/run_migrations.ps1 (Windows) or scripts/run_migrations.sh (Unix) for upgrade + check.
- MUST guard all schema modifications with inspector checks.
- MUST always recreate tables via batch mode when altering columns or constraints.
- MUST log output to tmp/alembic_drift.txt.
- MUST report but not fail when drift is detected.
- MUST NEVER run alembic check directly.
- MUST NEVER add/drop foreign keys outside batch mode.
- MUST NEVER modify column types without recreation.
- MUST NEVER leave downgrades unimplemented or unsafe.
- MUST NEVER use SQLite-unsupported DDL.

Drift Handling Workflow:
1. If tmp/alembic_drift.txt reports drift, run: alembic revision --autogenerate -m "sync models <scope>"
2. Edit migration for SQLite safety (batch_alter_table(recreate="always")).
3. Run: alembic upgrade head
4. Re-run safe check: python scripts/alembic_check_safe.py
5. Repeat until no new operations are detected.

Safe Commands Reference:
- Upgrade DB: alembic upgrade head
- Check drift (safe): python scripts/alembic_check_safe.py
- Full run (Cursor): scripts/run_migrations.ps1 (Windows) or scripts/run_migrations.sh (Unix)

[dash_callback_validation]
Purpose: Prevent Dash callback errors from referencing nonexistent component IDs, duplicate callbacks, and common callback patterns that cause runtime failures.

Core Principles:
- All component IDs referenced in callbacks must exist in the layout.
- Output IDs should not be duplicated across callbacks without allow_duplicate=True.
- Input/Output/State IDs must match exactly (case-sensitive) between layout and callbacks.

Validation Rules (MUST FOLLOW):
1. Verify Input/Output/State IDs exist in layout:
   - After editing callback code, verify all component IDs in Input(), Output(), and State() exist in the corresponding layout files.
   - Use grep to search for component IDs: `grep -r "id=\"component-id\"" app/ui/`
   - Check for typos: component IDs are case-sensitive and must match exactly.

2. Check for duplicate Outputs:
   - If multiple callbacks update the same Output, all except one must use allow_duplicate=True.
   - Example: `Output("my-component", "value", allow_duplicate=True)`

3. Verify callback dependencies:
   - Ensure Input components are rendered before callbacks are registered.
   - Check that conditional components (e.g., in modals) have proper prevent_initial_call settings.

4. Common callback errors to check:
   - Typo in component ID: "product-name" vs "product-name" (typo)
   - Missing component in layout but referenced in callback
   - Component removed from layout but callback still references it
   - Wrong property name: "value" vs "data" vs "children"

Cursor Agent Behaviour Rules:
- AFTER editing callback code, MUST verify all Input/Output/State IDs exist in layout files.
- MUST use grep to search for component IDs: `grep -r "id=\"<component-id>\"" app/ui/`
- MUST check for duplicate Outputs and add allow_duplicate=True where needed.
- MUST verify callback Input/Output/State IDs match layout component IDs exactly (case-sensitive).
- MUST check that conditional components (modals, tabs) have proper prevent_initial_call settings.
- MUST NEVER commit callback code without verifying component IDs exist in layout.

Validation Checklist (Run after editing callbacks):
1. Extract all Input/Output/State IDs from modified callbacks.
2. Search for each ID in layout files using grep.
3. Verify exact match (case-sensitive, no typos).
4. Check for duplicate Outputs - add allow_duplicate=True if needed.
5. Verify prevent_initial_call is set appropriately for conditional components.

Example Validation:
```python
# After editing this callback:
@app.callback(
    Output("product-pricing-table", "data"),
    [Input("product-sku", "value")],  # ‚Üê Verify "product-sku" exists in layout
)

# Run: grep -r 'id="product-sku"' app/ui/
# Must find the component definition in a layout file.
```
